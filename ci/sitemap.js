/**
 * This script generates a sitemap.xml file for the website. It's meant to be run just before the site is deployed.
 * It also writes the NavigationList.tsx file with the list of links to be used in the sidebar.
 */

import { opendir, readFile, writeFile } from "fs/promises";
import { join } from "path";
import matter from "gray-matter";

// TODO: How do we not hardcode these?
const sectionSortTable = {
    resources: 1,
    topics: 2,
    "remote-authentication": 3,
    interactions: 4,
}
const pageSortTable = {
    intro: -5,
    reference: -4,
    authentication: -3,
  };

async function walk(path, filter) {
  let files = [];

  const dir = await opendir(path);

  for await (const item of dir) {
    const file = join(dir.path, item.name);
    if (item.isFile()) {
      if (filter(file)) files.push(file);
    }

    if (item.isDirectory()) {
      files = files.concat(await walk(file, filter));
    }
  }

  return files;
}

const BASE_DOMAIN = process.env.VERCEL_PROJECT_PRODUCTION_URL ?? "docs.discord.sex";
// add domain
const createLink = (url) => `https://${BASE_DOMAIN}/${url}`;

function generateSiteMap(pages) {
  return `<?xml version="1.0" encoding="UTF-8"?>
   <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
     ${pages.map((url) => `<url><loc>${createLink(url)}</loc></url>`).join("\n     ")}
   </urlset>
 `;
}

const root = join(process.cwd(), "pages");
const files = [
  ...(await walk(
    root,
    (file) => file.endsWith(".mdx") && file.replaceAll("\\", "/").replace(`${root}/`, "").split("/").length !== 1,
  )),
]
  // Fix for Windows
  .map((file) => file.slice(root.length + 1, -4).replaceAll("\\", "/"))
  // Prioritize the root pages
  .sort((element) => ((pageSortTable[element] ?? element.includes("/")) ? 1 : 0))
  // Hide testing pages
  .filter((element) => !element.startsWith("_"));

// We generate the XML sitemap with the posts data
const sitemap = generateSiteMap(files);
const navigationLinks = {};
const headerRegex = /(?<header>#+) (?<name>.*)/;

for (const file of files) {
  let [section, link] = file.split("/");
  if (link == undefined) {
    // Special case for root pages
    link = section;
    section = null;
  }
  const parsed = await readFile(join(root, file + ".mdx"), "utf-8").then(matter);

  const sectionList = navigationLinks[section] ?? {name: section ? section.replaceAll("-", " ").replace(/(^\w|\s\w)/g, m => m.toUpperCase()) : null, pages: {}};
  const page = sectionList.pages[link] ?? {
    name: parsed.data.name ?? parsed.content.trim().split("\n")[0].replace("# ", ""),
    link: `/${file}`,
    subLinks: [],
    sort: parsed.data.sort ?? Number.MAX_SAFE_INTEGER,
  };
  // I hate javascript with all my heart
  sectionList.pages[link] = page;
  navigationLinks[section] = sectionList;

  if (!(parsed.data["show-sublinks"] ?? true)) continue;
  const allowedSubLinks = parsed.data.sublinks;

  // We must go line-by-line to make sure we're not in a codeblock
  let inCodeBlock = false;
  for (const line of parsed.content.split("\n")) {
    if (line.startsWith("```")) inCodeBlock = !inCodeBlock;
    if (inCodeBlock) continue;

    const match = line.match(headerRegex);
    if (match == null) continue;
    const { groups: { name, header } } = match;

    if (header.length < 2 || header.length > (parsed.data["max-sublink-level"] ?? 3)) continue;
    const subLinkName = name.toLowerCase().replaceAll(" ", "-");
    if (allowedSubLinks && !allowedSubLinks.includes(subLinkName)) continue;
    page.subLinks.push({
      link: `/${file}#${subLinkName}`,
      name: name,
      level: header.length,
    });
  }

  // Sanity check
  if (allowedSubLinks && page.subLinks.length != allowedSubLinks.length) {
    console.error(`Invalid data.sublinks in /${file}`);
  }
}

// TODO: Can I avoid sorting here?
for (const section in navigationLinks) {
  navigationLinks[section].pages = Object.values(navigationLinks[section].pages).sort((a, b) => a.sort - b.sort);
}
const navigationLinksArray = Object.entries(navigationLinks).map(([section, data]) => ({...data, section})).sort((a, b) => sectionSortTable[a.section] - sectionSortTable[b.section]);
const navigationList = `// This file is automatically generated. Do not edit it manually. Run \`pnpm sitemap\` to regenerate it.

import { NavigationSection, NavigationLink, NavigationSubLink, SearchItem } from "./NavigationItems";

interface Page {
  name: string;
  link: string;
  subLinks: SubLink[];
  sort: number;
}

interface SubLink {
  link: string;
  name: string;
  level: number;
}

interface Section {
  section: string | null;
  name: string | null;
  pages: Page[];
}

function createSubLink(element: SubLink): JSX.Element {
  return <NavigationSubLink href={element.link}>{element.name}</NavigationSubLink>;
}

function createLink(element: Page): JSX.Element {
  return (
    <NavigationLink href={element.link} subLinks={element.subLinks.map(createSubLink)}>
      {element.name}
    </NavigationLink>
  );
}

function createSection(element: Section): JSX.Element {
  return (
    <NavigationSection title={element.name || undefined}>
      {element.name === null ? SearchItem : null}
      {element.pages.map((page) => createLink(page))}
    </NavigationSection>
  );
}

export default function NavigationList() {
    const sections: Section[] = JSON.parse(\`${JSON.stringify(navigationLinksArray)}\`);
    return sections.map((section) => createSection(section));
}
`;

await writeFile(join(process.cwd(), "public", "sitemap.xml"), sitemap);
await writeFile(join(process.cwd(), "components", "NavigationList.tsx"), navigationList);
