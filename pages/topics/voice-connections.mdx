# Voice

Voice connections operate in a similar fashion to the [Gateway](/topics/gateway#connections) connection.
However, they use a different set of payloads and a separate UDP-based connection for voice data transmission.
Because UDP is generally used for both receiving and transmitting voice data, your client _must_ be able to receive UDP packets, even through a firewall or NAT (see [UDP Hole Punching](https://en.wikipedia.org/wiki/UDP_hole_punching) for more information).
The Discord voice servers implement functionality (see [IP Discovery](#ip-discovery)) for discovering the local machine's remote UDP IP/Port, which can assist in some network configurations.
If you cannot support a UDP connection, you may implement a [WebRTC connection](#webrtc-connections) instead.

While video from a camera feed is sent in the same connection as voice, streaming (the "Go Live" feature) uses seperate [Gateway Opcodes](/topics/gateway) and a second below voice connection.

## Voice Gateway

To ensure that you have the most up-to-date information, please use [version 8](#gateway-versions). Otherwise, the events and commands documented here may not reflect what you receive over the socket. Video is only fully supported on Gateway v5 and above.

###### Gateway Versions

<Alert type="info">

The voice server does not provide a default version. You must explicitly pass a version with the `?v=` query parameter.

</Alert>

| Version | Status      | Change                                                                            |
| ------- | ----------- | --------------------------------------------------------------------------------- |
| 8       | Recommended | Added buffered resuming                                                           |
| 7       | Available   | Added [Opcode 17 Channel Options Update](#gateway-events)                         |
| 6       | Available   | Added [Opcode 16 Voice Backend Version](#gateway-events)                          |
| 5       | Available   | Added [Opcode 15 Media Sink Wants](#gateway-events)                               |
| 4       | Available   | Changed [speaking status](#speaking-flags) from boolean to bitmask                |
| 3       | Deprecated  | Added video functionality, consolidated [Opcode 1 Hello](#gateway-events) payload |
| 2       | Deprecated  | Changed Gateway heartbeat reply to [Opcode 6 Heartbeak ACK](#gateway-events)      |
| 1       | Deprecated  | Initial version                                                                   |

###### Gateway Commands

| Name                                                      | Description                               |
| --------------------------------------------------------- | ----------------------------------------- |
| [Identify](#identify-structure)                           | Start a new voice connection              |
| [Resume](#resume-structure)                               | Resume a dropped connection               |
| [Heartbeat](#example-heartbeat-since-v8)                  | Maintain an active WebSocket connection   |
| [Select Protocol](#select-protocol-structure)             | Select the voice protocol and mode        |
| [Session Update](#session-update-structure-(send))        | Indicate the client's supported codecs    |
| [Speaking](#speaking-structure)                           | Indicate the user's speaking state        |
| [Voice Backend Version](#voice-backend-version-structure) | Request the current voice backend version |

###### Gateway Events

| Name                                                                | Description                                                                                                          |
| ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| [Hello](#hello-structure)                                           | Defines the heartbeat interval                                                                                       |
| [Heartbeat ACK](#example-heartbeat-ack-since-v8)                    | Acknowledges a received client heartbeat                                                                             |
| [Ready](#ready-structure)                                           | Contains SSRC, IP/Port, experiment, and encryption mode information                                                  |
| [Resumed](#example-resumed)                                         | Acknowledges a successful connection resume                                                                          |
| [Session Description](#session-description-structure)               | Acknowledges a successful Select Protocol and contains the information needed to send/receive voice data             |
| [Session Update](#session-update-structure-(receive))               | Client session description changed                                                                                   |
| [Speaking](#speaking-structure)                                     | User speaking state updated                                                                                          |
| [Client Connect](#client-connections)                               | A user connected to voice, also sent on initial connection to inform the client of existing users                    |                                                                                 |
| [Client Disconnect](#client-disconnections)                         | A user disconnected from voice                                                                                       |
| [Voice Backend Version](<#example-voice-backend-version-(receive)>) | Current voice backend version information, as requested by the client                                                |
| [Client Flags](#client-connections)                                 | Contains the flags of a user that connected to voice, also sent on initial connection for each existing user         |
| [Client Platform](#client-connections)                              | Contains the platform type of a user that connected to voice, also sent on initial connection for each existing user |

## Connecting to Voice

### Retrieving Voice Server Information

The first step in connecting to a voice server (and in turn, a guild's voice channel or private channel) is formulating a request that can be sent to the [Gateway](/topics/gateway), which will return information about the voice server we will connect to. Because Discord's voice platform is widely distributed, users **should never** cache or save the results of this call. To inform the Gateway of our intent to establish voice connectivity, we first send an [Update Voice State](/topics/gateway-events#update-voice-state) payload.

If our request succeeded, the Gateway will respond with _two_ events—a [Voice State Update](/topics/gateway-events#voice-state-update) event and a [Voice Server Update](/topics/gateway-events#voice-server-update) event—meaning you must properly wait for both events before continuing. The first will contain a new key, `session_id`, and the second will provide voice server information we can use to establish a new voice connection.

With this information, we can move on to establishing a voice WebSocket connection.

When changing channels within the same guild, it is possible to receive a [Voice Server Update](/topics/gateway-events#voice-server-update) with the same `endpoint` as the existing session. However, the `token` will be changed and you cannot re-use the previous session during a channel change, even if the endpoint remains the same.

<Alert type="info">

When the voice channel user limit is reached (the channel is full), you will not receive the two events in response to your request.
Having the `MANAGE_CHANNELS` permission bypasses this limit and allows you to join regardless of the channel being full or not.

</Alert>

### Establishing a Voice WebSocket Connection

Once we retrieve a `session_id`, `token`, and `endpoint` information, we can connect and handshake with the voice server over another secure WebSocket. Unlike the Gateway endpoint we receive in a [Get Gateway](/topics/gateway#get-gateway) request, the endpoint received from our [Voice Server Update](/topics/gateway-events#voice-server-update) payload does not contain a URL protocol, so some libraries may require manually prepending it with `wss://` before connecting. Once connected to the voice WebSocket endpoint, we can immediately send an [Opcode 0 Identify](#gateway-commands) payload with our `server_id`, `user_id`, `session_id`, and `token`:

###### Identify Structure

| Field      | Type                                      | Description                                                |
| ---------- | ----------------------------------------- | ---------------------------------------------------------- |
| server_id  | snowflake                                 | The ID of the guild or private channel being connecting to |
| user_id    | snowflake                                 | The ID of the current user                                 |
| session_id | string                                    | The session ID of the current session                      |
| token      | string                                    | The voice token for the current session                    |
| video?     | boolean                                   | Whether or not this connection supports video              |
| streams?   | array[[stream](#stream-structure) object] | An array of stream objects                                 |

###### Stream Structure

| Field      | Type                                      | Description                                                |
| ---------- | ----------------------------------------- | ---------------------------------------------------------- |
| server_id  | snowflake                                 | The ID of the guild or private channel being connecting to |
| user_id    | snowflake                                 | The ID of the current user                                 |
| session_id | string                                    | The session ID of the current session                      |
| token      | string                                    | The voice token for the current session                    |
| video?     | boolean                                   | Whether or not this connection supports video              |
| streams?   | array[[stream](#stream-structure) object] | An array of stream objects                                 |

```ts
export type MediaEngineSinkWantValue = 0 | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;

enum MediaTypes {
  AUDIO = 'audio',
  VIDEO = 'video',
  SCREEN = 'screen',
}

enum ResolutionTypes {
  FIXED = 'fixed',
  SOURCE = 'source',
}

interface StreamResolution {
  type: ResolutionTypes;
  width: number;
  height: number;
}

interface StreamParametersWire {
  type: MediaTypes;
  ssrc: number;
  rtx_ssrc: number;
  rid: string;
  quality: MediaEngineSinkWantValue;
  active: boolean;
  max_bitrate?: number;
  max_framerate?: number;
  max_resolution?: StreamResolution;
}
```

###### Example Identify

```json
{
  "op": 0,
  "d": {
    "server_id": "41771983423143937",
    "user_id": "104694319306248192",
    "session_id": "my_session_id",
    "token": "my_token",
    "video": true,
    "streams": []
  }
}
```

The voice server should respond with an [Opcode 2 Ready](#gateway-events) payload, which informs us of the SSRC, connection IP/port, supported encryption modes, and experiments the voice server supports:

###### Ready Structure

| Field       | Type                                      | Description                                  |
| ----------- | ----------------------------------------- | -------------------------------------------- |
| ssrc        | integer                                   | The SSRC of the user's voice connection      |
| ip          | string                                    | The IP address of the voice server           |
| port        | integer                                   | The port of the voice server                 |
| modes       | array[string]                             | An array of supported voice encryption modes |
| experiments | array[string]                             | An array of available voice experiments      |
| streams     | array[[stream](#stream-structure) object] | An array of available video streams          |

###### Example Ready

```json
{
  "op": 2,
  "d": {
    "ssrc": 1,
    "ip": "127.0.0.1",
    "port": 1234,
    "modes": [
      "aead_aes256_gcm_rtpsize",
      "aead_aes256_gcm",
      "aead_xchacha20_poly1305_rtpsize",
      "xsalsa20_poly1305_lite_rtpsize",
      "xsalsa20_poly1305_lite",
      "xsalsa20_poly1305_suffix",
      "xsalsa20_poly1305"
    ],
    "experiments": ["fixed_keyframe_interval"],
    "streams": []
  }
}
```

### Establishing a Voice Connection

Once we receive the properties of a voice server from our [Ready](#ready-structure) payload, we can proceed to the final step of voice connections, which entails establishing and handshaking a connection for voice data.
First, we establish either a [UDP connection](#udp-connections) using the [Ready](#ready-structure) payload data, or prepare a [WebRTC](#webrtc-connections) SDP. We then send an [Opcode 1 Select Protocol](#gateway-events) with details about our connection:

###### Select Protocol Structure

| Field              | Type                                                 | Description                                                  |
| ------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| protocol           | string                                               | The [voice protocol](#protocol-type) to use                  |
| data               | ?[protocol data](#protocol-data-structure) \| string | The voice connection data or WebRTC SDP                      |
| rtc_connection_id? | string                                               | The UUID4 RTC connection ID, used for analytics              |
| codecs?            | array[[codec](#codec-structure) object]              | The supported audio/video codecs                             |
| experiments?       | array[string]                                        | The [received voice experiments](#ready-structure) to enable |

###### Protocol Type

| Value  | Description                                       |
| ------ | ------------------------------------------------- |
| udp    | [Standard UDP voice connection](#udp-connections) |
| webrtc | [WebRTC voice connection](#webrtc-connections)    |

###### Protocol Data Structure

| Field       | Type    | Description                                    |
| ----------- | ------- | ---------------------------------------------- |
| address ^1^ | string  | The discovered IP address of the client        |
| port ^1^    | integer | The discovered UDP port of the client          |
| mode        | string  | The [encryption mode](#encryption-mode) to use |

^1^ These fields are only used to receive voice data. If you do not care about receiving voice data, you can randomize these values.

###### Codec Structure

| Field              | Type    | Description                                                                 |
| ------------------ | ------- | --------------------------------------------------------------------------- |
| name               | string  | The [name of the codec](#supported-codecs)                                  |
| type               | string  | The [type of codec](#supported-codecs)                                      |
| priority ^1^       | integer | The preferred priority of the codec as a multiple of 1000 (unique per type) |
| payload_type ^2^   | integer | The dynamic RTP payload type of the codec                                   |
| rtx_payload_type?  | integer | The dynamic RTP payload type of the retransmission codec (video-only)       ||
| encode?            | boolean | Whether the client supports encoding this codec (default `true`)            |
| decode?            | boolean | Whether the client supports decoding this codec (default `true`)            |

^1^ For audio, opus is the only available codec and should be priority `1000`.

^2^ No payload type should be set to `96`, as it is reserved for probe packets.

###### Supported Codecs

Providing codecs is optional due to backwards compatibility with old clients and bots that do not handle video.
If the client does not provide any codecs, the server assumes an opus audio codec with a payload type of `120` and no specific video codec.
If no clients with specified video codecs are connected, the server defaults to H264.

| Type  | Name  | Status    |
| ----- | ----- | --------- |
| audio | opus  | Required  |
| video | AV1   | Preferred |
| video | H265  | Preferred |
| video | H264  | Default   |
| video | VP8   | Available |
| video | VP9   | Available |

###### Example Select Protocol

```json
{
  "op": 1,
  "d": {
    "protocol": "udp",
    "data": {
      "address": "127.0.0.1",
      "port": 1337,
      "mode": "aead_aes256_gcm_rtpsize"
    },
    "codecs": [
      {
        "name": "opus",
        "type": "audio",
        "priority": 1000,
        "payload_type": 120
      },
      {
        "name": "AV1",
        "type": "video",
        "priority": 1000,
        "payload_type": 101,
        "rtx_payload_type": 102,
        "encode": false,
        "decode": true
      },
      {
        "name": "H264",
        "type": "video",
        "priority": 2000,
        "payload_type": 103,
        "rtx_payload_type": 104,
        "encode": true,
        "decode": true
      }
    ],
    "rtc_connection_id": "d6b92f64-40df-48eb-8bce-7facb043149a",
    "experiments": ["fixed_keyframe_interval"]
  }
}
```

###### Encryption Mode

The RTP size variants determine the unencrypted size of the RTP header in [the same way as SRTP](https://tools.ietf.org/html/rfc3711#section-3.1), which considers CSRCs and (optionally) the extension preamble to be part of the unencrypted header.
The deprecated variants use a fixed size unencrypted header for RTP.

The Gateway will report what encryption modes are available in [Opcode 2 Ready](#gateway-events).
Compatible modes will always include `aead_xchacha20_poly1305_rtpsize` but may not include `aead_aes256_gcm_rtpsize` depending on the underlying hardware. You must support `aead_xchacha20_poly1305_rtpsize`. You should prefer to use `aead_aes256_gcm_rtpsize` when it is available.

| Value                           | Name                               | Nonce                                                 | Status     |
| ------------------------------- | ---------------------------------- | ----------------------------------------------------- | ---------- |
| aead_aes256_gcm_rtpsize         | AEAD AES256 GCM (RTP Size)         | 32-bit incremental integer value appended to payload  | Preferred  |
| aead_xchacha20_poly1305_rtpsize | AEAD XChaCha20 Poly1305 (RTP Size) | 32-bit incremental integer value appended to payload  | Required   |
| xsalsa20_poly1305_lite_rtpsize  | XSalsa20 Poly1305 Lite (RTP Size)  | 32-bit incremental integer value appended to payload  | Deprecated |
| aead_aes256_gcm                 | AEAD AES256-GCM                    | 32-bit incremental integer value appended to payload  | Deprecated |
| xsalsa20_poly1305               | XSalsa20 Poly1305                  | Copy of RTP header                                    | Deprecated |
| xsalsa20_poly1305_suffix        | XSalsa20 Poly1305 (Suffix)         | 24 random bytes                                       | Deprecated |
| xsalsa20_poly1305_lite          | XSalsa20 Poly1305 (Lite)           | 32-bit incremental integer value, appended to payload | Deprecated |

Finally, the voice server will respond with an [Opcode 4 Session Description](#gateway-events) that includes the `mode` and `secret_key`, a 32 byte array used for [sending and receiving](#sending-and-receiving-voice) voice data:

###### Session Description Structure

| Field              | Type           | Description                                                              |
| ------------------ | -------------- | ------------------------------------------------------------------------ |
| audio_codec        | string         | The audio codec to use                                                   |
| video_codec        | string         | The video codec to use                                                   |
| media_session_id   | string         | The media session ID, used for analytics                                 |
| mode?              | string         | The [encryption mode](#encryption-mode) to use, not applicable to WebRTC |
| secret_key?        | array[integer] | The 32 byte secret key used for encryption, not applicable to WebRTC     |
| sdp?               | string         | The WebRTC session description protocol                                  |
| keyframe_interval? | integer        | The keyframe interval in milliseconds                                    |

###### Example Session Description

```json
{
  "op": 4,
  "d": {
    "audio_codec": "opus",
    "media_session_id": "89f1d62f166b948746f7646713d39dbb",
    "mode": "aead_aes256_gcm_rtpsize",
    "secret_key": [ ... ],
    "video_codec": "H264"
  }
}
```

We can now start sending and receiving voice data over the previously established [UDP](#udp-connections) or [WebRTC](#webrtc-connections) connection.

### Session Updates

At any time, the client may update the `codecs` they support using an [Opcode 14 Session Update](#gateway-events).
If a user joins that does not support the current codecs, or a user indicates that they no longer support the current codecs, the voice server will send an [Opcode 14 Session Update](#gateway-events):

This may also be sent to update the current `media_session_id` or `keyframe_interval`.

###### Session Update Structure (Send)

| Field  | Type                                    | Description                      |
| ------ | --------------------------------------- | -------------------------------- |
| codecs | array[[codec](#codec-structure) object] | The supported audio/video codecs |

###### Session Update Structure (Receive)

| Field              | Type    | Description                                  |
| ------------------ | ------- | -------------------------------------------- |
| audio_codec?       | string  | The new audio codec to use                   |
| video_codec?       | string  | The new video codec to use                   |
| media_session_id?  | string  | The new media session ID, used for analytics |
| keyframe_interval? | integer | The keyframe interval in milliseconds        |

## Heartbeating

In order to maintain your WebSocket connection, you need to continuously send heartbeats at the interval determined in [Opcode 8 Hello](#gateway-events).

This is sent at the start of the connection. Be warned that the [Opcode 8 Hello](#gateway-events) structure differs by Gateway version.
Versions below v3 follow a flat structure without `op` or `d` fields, including only a single `heartbeat_interval` field. Be sure to expect this different format based on your version.

This heartbeat interval is the minimum interval you should heartbeat at. You can heartbeat at a faster interval if you wish.
For example, the web client uses a heartbeat interval of `min(heartbeat_interval, 5000)` if the Gateway version is v4 or above, and `heartbeat_interval * 0.1` otherwise. The desktop client uses the provided heartbeat interval if the Gateway version is v4 or above, and `heartbeat_interval * 0.25` otherwise.

###### Hello Structure

| Field              | Type    | Description                                                           |
| ------------------ | ------- | --------------------------------------------------------------------- |
| v                  | integer | The [voice server version](#gateway-versions)                         |
| heartbeat_interval | integer | The minimum interval (in milliseconds) the client should heartbeat at |

###### Example Hello

```json
{
  "op": 8,
  "d": {
    "v": 8,
    "heartbeat_interval": 41250
  }
}
```

The Gateway may request a heartbeat from the client in some situations by sending an [Opcode 3 Heartbeat](#gateway-events). When this occurs, the client should immediately send an [Opcode 3 Heartbeat](#gateway-events) without waiting the remainder of the current interval.

After receiving [Opcode 8 Hello](#gateway-events), you should send [Opcode 3 Heartbeat](#gateway-events)—which contains an integer nonce—every elapsed interval:

###### Heartbeat Structure

| Field    | Type    | Description                                              |
| -------- | ------- | -------------------------------------------------------- |
| t        | integer | A unique integer nonce (e.g. the current unix timestamp) |
| seq_ack? | integer | The last received sequence number                        |

###### Example Heartbeat

```json
{
  "op": 3,
  "d": {
    "t": 1501184119561,
    "seq_ack": 10
  }
}
```

Since Gateway v8, heartbeat messages must include `seq_ack` which contains the sequence number of the last numbered message received from the gateway. See [Buffered Resume](#buffered-resume) for more information.
Previous versions follow a flat structure, with the `d` field representing the `t` field in both the [Heartbeat](#example-heartbeat) and [Heartbeat ACK](#example-heartbeat-ack) structure.

In return, you will be sent back an [Opcode 6 Heartbeat ACK](#gateway-events) that contains the previously sent nonce:

###### Example Heartbeat ACK

```json
{
  "op": 6,
  "d": {
    "t": 1501184119561
  }
}
```

## UDP Connections

UDP is the most likely protocol that clients will use. First, we open a UDP connection to the IP and port provided in the Ready payload. If required, we can now perform an [IP Discovery](#ip-discovery) using this connection.
Once we've fully discovered our external IP and UDP port, we can then tell the voice WebSocket what it is by sending a [Select Protocol](#select-protocol-structure) as outlined above, and receive our [Session Description](#session-description-structure) to begin sending/receiving voice data.

##### IP Discovery

Generally routers on the Internet mask or obfuscate UDP ports through a process called NAT. Most users who implement voice will want to utilize IP discovery to find their external IP and port which will then be used for receiving voice communications. To retrieve your external IP and port, send the following UDP packet to your voice port (all numeric are big endian):

| Field   | Description                                                    | Size     |
| ------- | -------------------------------------------------------------- | -------- |
| Type    | Values 0x1 and 0x2 indicate request and response, respectively | 2 bytes  |
| Length  | Message length excluding Type and Length fields (value 70)     | 2 bytes  |
| SSRC    | Unsigned integer                                               | 4 bytes  |
| Address | Null-terminated string in response                             | 64 bytes |
| Port    | Unsigned short                                                 | 2 bytes  |

##### Sending and Receiving Voice

Voice data sent to and received from Discord should be encoded or decoded with [Opus](https://www.opus-codec.org/), using two channels (stereo) and a sample rate of 48kHz. Voice Data is sent using a [RTP Header](https://www.rfcreader.com/#rfc3550_line548), followed by encrypted Opus audio data. Voice encryption uses the key passed in [Session Description](#session-description-structure) and the nonce formed with the 12 byte header appended with 12 `null` bytes, if required. Discord encrypts with the [libsodium](https://download.libsodium.org/doc/) encryption library.

When receiving data, the user who sent the voice packet is identified by caching the SSRC and user IDs received from [Speaking](#speaking) events. At least one [Speaking](#speaking) event for the user is received before any voice data is received, so the user ID should always be available.

<Alert type="warn">

The nonce has to be stripped from the payload before encrypting or decrypting audio data.

</Alert>

###### Voice Packet Structure

| Field           | Type                          | Size    |
| --------------- | ----------------------------- | ------- |
| Version + Flags | Single byte value of `0x80`   | 1 byte  |
| Payload Type    | Single byte value of `0x78`   | 1 byte  |
| Sequence        | Unsigned short (big endian)   | 2 bytes |
| Timestamp       | Unsigned integer (big endian) | 4 bytes |
| SSRC            | Unsigned integer (big endian) | 4 bytes |
| Encrypted Audio | Binary data                   | n bytes |

## WebRTC Connections

WebRTC allows for direct peer-to-peer voice connections, and is most commonly used in browsers. To use WebRTC, you must first send a [Select Protocol](#establishing-a-voice-connection) payload as outlined above, with the `protocol` field set to `webrtc`, and `data` set to the client's WebRTC SDP. The voice server will respond with a [Session Description](#session-description-structure) payload, with the `sdp` field set to the server's WebRTC SDP. The client can then use this SDP to establish a WebRTC connection.

## Speaking

To notify the voice server that you are speaking or have stopped speaking, send an [Opcode 5 Speaking](#gateway-commands) payload:

<Alert type="warn">

You must send at least one Speaking payload before sending or receiving voice data, or you will be disconnected with an Invalid SSRC error.

</Alert>

###### Speaking Structure

| Field        | Type      | Description                           |
| ------------ | --------- | ------------------------------------- |
| speaking ^1^ | integer   | The [speaking flags](#speaking-flags) |
| ssrc         | integer   | The SSRC of the speaking user         |
| user_id ^2^  | snowflake | The user ID of the speaking user      |
| delay? ^3^   | integer   | The speaking packet delay             |

^1^ For Gateway v3 and below, this field is a boolean.

^2^ Only sent by the voice server.

^3^ Not sent by the voice server.

###### Speaking Flags

The following flags can be used as a bitwise mask. For example `5` would be priority and voice.

| Value  | Name       | Description                                                    |
| ------ | ---------- | -------------------------------------------------------------- |
| 1 << 0 | VOICE      | Normal transmission of voice audio                             |
| 1 << 1 | SOUNDSHARE | Transmission of context audio for video, no speaking indicator |
| 1 << 2 | PRIORITY   | Priority speaker, lowering audio of other speakers             |

###### Example Speaking (Send)

```json
{
  "op": 5,
  "d": {
    "speaking": 5,
    "delay": 0,
    "ssrc": 1
  }
}
```

When a different user's speaking state is updated, the voice server will send an [Opcode 5 Speaking](#gateway-events) payload:

###### Example Speaking (Receive)

```json
{
  "op": 5,
  "d": {
    "speaking": 5,
    "ssrc": 2,
    "user_id": "852892297661906993"
  }
}
```

### Voice Data Interpolation

When there's a break in the sent data, the packet transmission shouldn't simply stop. Instead, send five frames of silence (`0xF8, 0xFF, 0xFE`) before stopping to avoid unintended Opus interpolation with subsequent transmissions.

Likewise, when you receive these five frames of silence, you know that the user has stopped speaking.

## Resuming Voice Connection

When your client detects that its connection has been severed, it should open a new WebSocket connection. Once the new connection has been opened, your client should send an [Opcode 7 Resume](#gateway-commands) payload:

###### Resume Structure

| Field        | Type      | Description                                                |
| ------------ | --------- | ---------------------------------------------------------- |
| server_id    | snowflake | The ID of the guild or private channel being connecting to |
| session_id   | string    | The session ID of the current session                      |
| token        | string    | The voice token for the current session                    |
| seq_ack? ^1^ | integer   | The last received sequence number                          |

^1^ Only available on Gateway v8 and above.

###### Example Resume

```json
{
  "op": 7,
  "d": {
    "server_id": "41771983423143937",
    "session_id": "my_session_id",
    "token": "my_token"
  }
}
```

If successful, the voice server will respond with an [Opcode 9 Resumed](#gateway-commands) to signal that your client is now resumed:

###### Example Resumed

```json
{
  "op": 9,
  "d": null
}
```

If the resume is unsuccessful—for example, due to an invalid session—the WebSocket connection will close with the appropriate [close code](/topics/opcodes-and-status-codes#voice-close-event-codes). You should then follow the [Connecting](#connecting-to-voice) flow to reconnect.

### Buffered Resume

Since version 8, the Gateway can resend buffered messages that have been lost upon resume. To support this, the Gateway includes a sequence number with all messages that may need to be re-sent.

###### Example Message With Sequence Number

```json
{
  "op": 5,
  "d": {
    "speaking": 0,
    "delay": 0,
    "ssrc": 110
  },
  "seq": 10
}
```

A client using Gateway v8 must include the last sequence number they received under the data `d` key as `seq_ack` in both the [Opcode 3 Heartbeat](#gateway-commands) and [Opcode 7 Resume](#gateway-commands) payloads.
If no sequence numbered messages have been received, `seq_ack` can be omitted or included with a value of -1.

The Gateway uses a fixed bit length sequence number and handles wrapping the sequence number around. Since Gateway messages will always arrive in order, a client only needs to retain the last sequence number they have seen.

If the session is successfully resumed, the Gateway will respond with an [Opcode 9 Resumed](#gateway-events) and will re-send any messages that the client did not receive.

The resume may be unsuccessful if the buffer for the session no longer contains a message that has been missed. In this case the session will be closed and you should then follow the [Connecting](#connecting-to-voice) flow to reconnect.

## Connected Clients

### Client Connections

At connection start, and when a client thereafter connects to voice, the voice server will send a series of events, including an [Opcode 11 Client Connect](#gateway-events), and [Opcode 18 Client Flags](#gateway-events) and [Opcode 20 Client Platform](#gateway-events) for every joined user.

These events are meant to inform a new client of all existing clients and their flags/platform, and inform existing clients of a newly-connected client.

###### Client Connect Structure

| Field    | Type      | Description                         |
| -------- | --------- | ----------------------------------- |
| user_ids | snowflake | The IDs of the users that connected |

###### Example Client Connect

```json
{
  "op": 11,
  "d": {
    "user_ids": [ "852892297661906993" ]
  }
}
```

###### Client Flags Structure

| Field   | Type      | Description                            |
| ------- | --------- | -------------------------------------- |
| user_id | snowflake | The ID of the user that connected      |
| flags   | ?integer  | The [user's voice flags](#voice-flags) |

###### Voice Flags

| Value  | Name                   | Description                                                                                      |
| ------ | ---------------------- | ------------------------------------------------------------------------------------------------ |
| 1 << 0 | CLIPS_ENABLED          | The user has [clips](https://support.discord.com/hc/en-us/articles/16861982215703-Clips) enabled |
| 1 << 1 | ALLOW_VOICE_RECORDING  | The user has allowed their voice to be recorded in another user's clips                          |
| 1 << 2 | ALLOW_ANY_VIEWER_CLIPS | The user has allowed stream viewers to clip them                                                 |

###### Example Client Flags

```json
{
  "op": 18,
  "d": {
    "user_id": "852892297661906993",
    "flags": 3
  }
}
```

###### Client Platform Structure

| Field    | Type      | Description                                  |
| -------- | --------- | -------------------------------------------- |
| user_id  | snowflake | The ID of the user that connected            |
| platform | integer   | The [user's voice platform](#voice-platform) |

###### Voice Platform

| Value  | Name        | Description             |
| ------ | ----------- | ----------------------- |
| 0      | DESKTOP     | Desktop-based client    |
| 1      | MOBILE      | Mobile client           |
| 2      | XBOX        | Xbox integration        |
| 3      | PLAYSTATION | PlayStation integration |

###### Example Client Platform

```json
{
  "op": 20,
  "d": {
    "user_id": "852892297661906993",
    "platform": 0
  }
}
```

### Client Disconnections

When a user disconnects from voice, the voice server will send an [Opcode 13 Client Disconnect](#gateway-events):

When received, the SSRC of the user should be discarded.

###### Client Disconnect Structure

| Field   | Type      | Description                          |
| ------- | --------- | ------------------------------------ |
| user_id | snowflake | The ID of the user that disconnected |

###### Example Client Disconnect

```json
{
  "op": 13,
  "d": {
    "user_id": "852892297661906993"
  }
}
```

## Voice Backend Version

For analytics, the client may want to receive information about the voice backend's current version. This is only available on Gateway v6 and above. To do so, send an [Opcode 16 Voice Backend Version](#gateway-commands) with an empty payload:

###### Voice Backend Version Structure

| Field      | Type   | Description                 |
| ---------- | ------ | --------------------------- |
| voice      | string | The voice backend's version |
| rtc_worker | string | The WebRTC worker's version |

###### Example Voice Backend Version (Send)

```json
{
  "op": 16,
  "d": {}
}
```

In response, the voice server will send an [Opcode 16 Voice Backend Version](#gateway-commands) payload with the versions:

###### Example Voice Backend Version (Receive)

```json
{
  "op": 16,
  "d": {
    "voice": "0.9.1",
    "rtc_worker": "0.3.35"
  }
}
```
